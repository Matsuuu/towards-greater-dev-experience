// matcher.ts
function createRouteMatcher(path) {
  const wildcards = path.match(/{.*?}(?:\(.*\))*/g);
  if (wildcards == null) {
    return void 0;
  }
  const pathSplit = path.split("/").filter((part) => part.length > 0);
  let regexString = "";
  for (const pathPart of pathSplit) {
    if (!wildcards.includes(pathPart)) {
      regexString += "\\/" + pathPart;
      continue;
    }
    const matcherKey = pathPart.substring(pathPart.indexOf("{") + 1, pathPart.indexOf("}"));
    let matcher = pathPart.match(/\(.*\)/)?.[0];
    if (!matcher) {
      matcher = "(.*)";
    }
    const matcherWithoutWrappingParenthesis = matcher.replace(/^\(/, "").replace(/\)$/, "");
    const matcherKeyRegex = `(?<${matcherKey}>${matcherWithoutWrappingParenthesis})`;
    regexString += "\\/" + matcherKeyRegex;
  }
  return new RegExp(regexString);
}

// route.ts
function isViewRoute(route) {
  return route.hasOwnProperty("view");
}
function isChildRoute(route) {
  return route.hasOwnProperty("isChild") && route.isChild === true;
}
function isRedirectRoute(route) {
  return route.hasOwnProperty("redirect");
}
function combinePaths(first, second) {
  const firstNeedsDelimiter = !first.endsWith("/");
  const secondNeedsDelimiter = !second.startsWith("/");
  if (firstNeedsDelimiter && secondNeedsDelimiter) {
    return `${first}/${second}`;
  }
  if (!firstNeedsDelimiter && !secondNeedsDelimiter) {
    return first + second.substring(1);
  }
  return first + second;
}

// triggers.ts
var NAVIGATED_EVENT = "suunta-navigated";
function onNavigation(onNavigationFunction) {
  document.addEventListener(NAVIGATED_EVENT, onNavigationFunction, { once: true });
}

// suunta.ts
var Suunta = class {
  constructor(options) {
    this.options = options;
    if (!this.options.renderer) {
      throw new Error("[Suunta]: No renderer set! Set a router in the Suunta initialization options or use the `suunta` -package with the default Lit renderer.\n\nimport { Suunta } from 'suunta';");
    }
    this.mapRoutes();
  }
  #currentView;
  #currentRenderTarget;
  routes = /* @__PURE__ */ new Map();
  routeMatchers = /* @__PURE__ */ new Map();
  started = false;
  mapRoutes() {
    this.options.routes.forEach((route) => this.mapRoute(route));
  }
  mapRoute(route) {
    this.routes.set(route.path, route);
    const routeMatcher = createRouteMatcher(route.path);
    if (routeMatcher) {
      this.routeMatchers.set(routeMatcher, route);
    }
    if (isViewRoute(route)) {
      route.children?.forEach((childRoute) => {
        const relativeChildRoute = {
          ...childRoute,
          path: combinePaths(route.path, childRoute.path),
          isChild: true,
          parent: route
        };
        this.mapRoute(relativeChildRoute);
      });
    }
  }
  async start() {
    const currentRoute = this.getRouteFromCurrentURL();
    this.setupListeners();
    await this.navigate(currentRoute);
    this.started = true;
  }
  setupListeners() {
    document.body.addEventListener("click", (clickEvent) => {
      clickEvent.preventDefault();
      const path = clickEvent.composedPath();
      const closestLink = path.filter((el) => el.href !== void 0).pop();
      if (!closestLink) {
        return;
      }
      const navigationTargetUrl = closestLink?.getAttribute("href") ?? void 0;
      const route = this.getRoute({ path: navigationTargetUrl });
      this.navigate(route);
    });
    window.addEventListener("popstate", () => {
      const currentRoute = this.getRouteFromCurrentURL();
      this.navigate(currentRoute, false);
    });
  }
  getTarget(parentRenderTarget) {
    const parent = parentRenderTarget ?? document;
    let soonToBeTarget = this.options.target;
    if (soonToBeTarget === void 0) {
      const outlet = parent.querySelector("suunta-view");
      if (!outlet) {
        throw new Error(`[Suunta]: No router target nor a outlet tag was set. Create a <suunta-view> element or specify a css selector for target div with

${JSON.stringify({ routes: [], target: "#my-div" }, null, 4)}
`);
      }
      return outlet;
    }
    if (typeof soonToBeTarget !== "string") {
      return soonToBeTarget;
    }
    let foundElement = parent.querySelector(soonToBeTarget);
    if (foundElement) {
      return foundElement;
    }
    throw new Error("[Suunta]: Can't find a router target");
  }
  async navigateTo(routeQueryObject) {
    const route = this.getRoute(routeQueryObject);
    await this.navigate(route);
  }
  getRoute(routeQueryObject) {
    if (routeQueryObject.name) {
      return [...this.routes.values()].find((route) => route.name === routeQueryObject.name);
    }
    if (!routeQueryObject.path) {
      throw new Error("[Suunta]: RouteQueryObject must contain either a name or a path");
    }
    const path = routeQueryObject.path;
    const matchedStaticPath = [...this.routes.values()].find((route) => route.path === path);
    if (matchedStaticPath) {
      return matchedStaticPath;
    }
    for (const matcherEntry of this.routeMatchers.entries()) {
      const matcher = matcherEntry[0];
      const match = path.match(matcher);
      if (!match) {
        continue;
      }
      const rawMatch = match[0];
      if (path !== rawMatch) {
        continue;
      }
      const matchedRoute = { ...matcherEntry[1] };
      matchedRoute.path = path;
      return {
        ...matchedRoute,
        properties: match.groups
      };
    }
    return void 0;
  }
  getRouteFromCurrentURL() {
    const currentURL = new URL(window.location.href);
    const path = currentURL.pathname;
    return this.getRoute({ path });
  }
  async navigate(route, pushState = true) {
    if (!route) {
      throw new Error(`[Suunta]: Could not find a route to navigate to, and no fallback route was set. 
                            To set a fallback route, add one with the matcher '/{notFoundPath}(.*)', or just '/{notFoundPath}'.`);
    }
    if (route === this.#currentView?.route) {
      return;
    }
    this.#currentView = {
      href: window.location.href,
      route,
      properties: { ...route.properties }
    };
    if (pushState) {
      window.history.pushState(null, "", route.path);
    }
    if (isViewRoute(route)) {
      await this.handleViewRoute(route);
      return;
    }
    if (isRedirectRoute(route)) {
      await this.handleRedirectRoute(route);
      return;
    }
  }
  async handleViewRoute(route) {
    let parentRenderTarget = void 0;
    if (isChildRoute(route)) {
      await this.handleViewRoute(route.parent);
      parentRenderTarget = this.#currentRenderTarget;
    }
    let renderableView = route.view;
    let iterationCount = 0;
    while (renderableView !== null) {
      if (isRenderableView(renderableView)) {
        this.render(renderableView, route, parentRenderTarget);
        break;
      }
      if (isFunction(renderableView)) {
        renderableView = await renderableView();
      }
      if (isModule(renderableView)) {
        const exportedView = renderableView.default ?? Object.values(renderableView)[0];
        if (exportedView) {
          renderableView = exportedView;
        } else {
          throw new Error("[Suunta]: Could not parse imported route.");
        }
      }
      iterationCount++;
      if (iterationCount > 10) {
        throw new Error("[Suunta]: Could not parse route from View. Recursion level too deep.");
      }
    }
  }
  async handleRedirectRoute(route) {
    const redirectTarget = this.getRoute({ name: route.redirect });
    if (!redirectTarget) {
      throw new Error("[Suunta]: Could not redirect to route '" + route.redirect + "' as it could not be found.");
    }
    this.navigate(redirectTarget);
  }
  render(viewToRender, route, parentRenderTarget) {
    const target = this.getTarget(parentRenderTarget);
    this.#currentRenderTarget = target;
    this.options.renderer(viewToRender, route, target);
    document.dispatchEvent(new CustomEvent(NAVIGATED_EVENT));
  }
  getCurrentView() {
    return this.#currentView;
  }
};
function isModule(something) {
  return Object.prototype.toString.call(something) === "[object Module]";
}
function isRenderableView(view) {
  return typeof view !== "function" && !isModule(view);
}
function isFunction(view) {
  return typeof view === "function";
}
export {
  NAVIGATED_EVENT,
  Suunta,
  onNavigation
};
